#include <chrono>
#include <future>
#include <thread>
#include <fstream>

#include "matching/matchingcommand.h"
#include "graph/graph.h"
#include "matching/GenerateFilteringPlan.h"
#include "matching/FilterVertices.h"
#include "matching/BuildTable.h"
#include "matching/GenerateQueryPlan.h"
#include "matching/EvaluateQuery.h"

#define qw cout<<endl;
#define dl endl
#define NANOSECTOSEC(elapsed_time) ((elapsed_time)/(double)1000000000)
#define BYTESTOMB(memory_cost) ((memory_cost)/(double)(1024 * 1024))
#define ti std::chrono::high_resolution_clock::now()
#define gti(x, y) std::chrono::duration_cast<std::chrono::nanoseconds>(y - x).count()
#define cti(x) NANOSECTOSEC(x)
#define fi first
#define se second
const string PATH = "95";
const int QUERY_NUMS = 3;
const int D = 2;
int SPECIAL = 2;
int debug_cnt = 0;
bool RE;
std::string input_query_graph_file = "../../test/querys/" + PATH;
std::string input_data_graph_file = "../../test/graphs/" + PATH + ".txt";
std::string input_filter_type = "CECI";
std::string input_order_type = "CECI";
std::string input_engine_type = "CECI";
std::string input_max_embedding_num = "MAX";
std::string input_time_limit = "60";
std::string input_order_num = "100";
std::string input_distribution_file_path = "temp.distribution";
std::string input_csr_file_path;
std::string method = "2";

bool dbg;
double t1, t2;
double sum_load_graphs_time_in_ns = 0;
double sum_filter_vertices_time_in_ns = 0;
double sum_build_table_time_in_ns = 0;
double sum_generate_query_plan_time_in_ns = 0;
double sum_enumeration_time_in_ns = 0;
double sum_preprocessing_time_in_ns = 0;
double sum_total_time_in_ns = 0;
size_t sum_memory_cost_in_bytes = 0;
size_t sum_embedding_count = 0;
size_t sum_call_count = 0;

int try_count;
int dfs_all_count;

vector<vector<int>> match_result;
vector<vector<int>> match_path;
vector<pair<int, int>> match_order;
vector<int> ORD;
unordered_map<int, vector<vector<vector<int>>>> matched;
bool query_is_matched[QUERY_NUMS];
int sp_match_res;

struct node {
    vector<int> match;
    int sum;
    node(const std::vector<int>& m, int s)
            : match(m), sum(s){
    }
    ~node(){}
};

unordered_map<int, unordered_map<int, vector<node>>>  match_st;
struct ifm {
    vector<int> fa;
    vector<vector<vector<int>>> match;
    vector<vector<pair<vector<int>, vector<int>>>> path;
};
unordered_map<int, vector<ifm>> re_use;

unordered_map<int, bool> dont_need_match_vertex;
long long queue_size[10];
long long avg_res;
int calculate_count;
long long res_size[10];
long long avg_res2;

bool in_file = true;
bool cot = false;

bool* cst;
struct ma {
    int tar;
    vector<int> match;
    vector<int> path;
    ma(int t, const vector<int>& m, const vector<int>& p): tar(t), match(m), path(p){}
    ~ma(){}
};
unordered_map<int, vector<ma>> cpath;
vector<int> cp;
unordered_map<int, vector<int>> v_q;
vector<pair<vector<int>, vector<int>>> show_path_vec;
bool is_show[QUERY_NUMS];
vector<pair<vector<int>, int>> show_match_result;
unordered_map<int, unordered_map<int, vector<int>>> get_nei_label_vertex;

void cal(Graph* data_graph, int u, int fa, int d, int depth, bool from_vertex, int this_match) {
    if (depth == QUERY_NUMS) {
        vector<vector<int>> match_;
        vector<pair<vector<int>, vector<int>>> path_;
        unordered_map<int, bool> tmp_st;
        ifm tmp;
        sp_match_res++;

//        auto match_result_bk = match_result;

//        for (auto& i : match_result) sort(i.begin(), i.end());

        if(RE) {
            tmp.fa.reserve(QUERY_NUMS);
            tmp.match.reserve(QUERY_NUMS);
            tmp.path.reserve(QUERY_NUMS);
            int sum = 0;

            // find father
            for (int i = 1; i < match_result.size(); ++i) {
                if (i) {
                    if (tmp_st.find(show_path_vec[i - 1].first.front()) == tmp_st.end()) {
                        int root = show_path_vec[i - 1].first.front();
                        int cur = show_match_result[i].second;

                        while (cur != 0) {
                            root = show_path_vec[cur - 1].first.front();
                            cur = show_match_result[cur].second;
                        }
                        if (tmp_st.find(root) == tmp_st.end())
                            tmp.fa.emplace_back(root);
                        tmp_st[show_path_vec[cur].first.front()] = true;
                    }
                }
                match_.emplace_back(match_result[ORD[i]]);
            }

            sort(tmp.fa.begin(), tmp.fa.end());
        }

        fstream fin;
        if (!RE)
            fin = fstream("../../result1.txt", ios::app);
        else
            fin = fstream("../../result_dfs2.txt", ios::app);

        for (int i = 0; i < QUERY_NUMS; ++i) {
            if (i) {
                if (cot) cout << "[";
                if (in_file) fin << "[";

                for (int j = 0; j < show_path_vec[i - 1].first.size() - 1; ++j) {
                    if (show_path_vec[i - 1].second[j] > 0) {
                        if (cot) cout << show_path_vec[i - 1].first[j] << "->" << show_path_vec[i - 1].first[j + 1] << " ";
                        if (in_file) fin << show_path_vec[i - 1].first[j] << "->" << show_path_vec[i - 1].first[j + 1] << " ";
                    } else if (show_path_vec[i - 1].second[j] < 0) {
                        if (cot) cout << abs(show_path_vec[i - 1].first[j]) << "<-" << show_path_vec[i - 1].first[j + 1] << " ";
                        if (in_file) fin << abs(show_path_vec[i - 1].first[j]) << "<-" << show_path_vec[i - 1].first[j + 1] << " ";
                    } else {
                        if (cot) cout << abs(show_path_vec[i - 1].first[j]) << "<->" << show_path_vec[i - 1].first[j + 1] << " ";
                        if (in_file) fin << abs(show_path_vec[i - 1].first[j]) << "<->" << show_path_vec[i - 1].first[j + 1] << " ";
                    }
                }

                if (show_path_vec[i - 1].first.size() == 1) {
                    if (cot) cout << show_path_vec[i - 1].first[0] << " ";
                    if (in_file) fin << show_path_vec[i - 1].first[0] << " ";
                }
                if (cot) cout << "] ";
                if (in_file) fin << "] ";
                if (RE) path_.emplace_back(show_path_vec[i - 1]);
            }

            for (auto j: match_result[ORD[i]]) {
                if (cot) cout << j << "(" << data_graph->getVertexLabel(j) << ")" << " ";
                if (in_file) fin << j <<"(" << data_graph->getVertexLabel(j) << ")" << " ";
            }
        }

        if (RE) {
            if (re_use.find(tmp.fa[0]) == re_use.end()) {
                tmp.match.emplace_back(match_);
                tmp.path.emplace_back(path_);
                re_use[tmp.fa[0]].emplace_back(tmp);
            } else {
                bool insert = true;
                for (auto &i: re_use[tmp.fa[0]]) {
                    if (i.fa.size() == tmp.fa.size()) {
                        bool ok = true;
                        for (int j = 0; j < i.fa.size(); ++j) {
                            if (i.fa[j] != tmp.fa[j]) {
                                ok = false;
                                break;
                            }
                        }
                        if (ok) {
                            insert = false;
                            i.match.emplace_back(match_);
                            i.path.emplace_back(path_);
                            break;
                        }
                    }
                }
                if (insert) {
                    tmp.match.emplace_back(match_);
                    tmp.path.emplace_back(path_);
                    re_use[tmp.fa[0]].emplace_back(tmp);
                }
            }
            fin << " fa ";
            for (auto tt : tmp.fa)
                fin << tt << " ";
        }

//        match_result = match_result_bk;
        if (cot) cout << dl;
        if (in_file) fin << dl;
        fin.close();

        return;
    }

    if (!from_vertex) {
        unordered_map<int, bool> ppp;
        for (int i = 0; i < QUERY_NUMS; ++i) {
            if (is_show[i]) continue;
            for (int j = show_match_result.size() - 1; j >= 0; --j) {
                for (auto ver: show_match_result[j].first) {
//                    is_show[i] = true;
                    if (ppp.find(ver) != ppp.end()) continue;
                    if (RE && depth == 1 && dont_need_match_vertex.find(ver) != dont_need_match_vertex.end()) continue;
                    ppp[ver] = true;
                    cp.emplace_back(ver);
                    cst[ver] = true;
                    cal(data_graph, ver, -1, 0, depth, true, j);
                    cst[ver] = false;
                    cp.pop_back();
//                    is_show[i] = false;
                }
            }
        }
    }
    else {
        if (v_q.find(u) != v_q.end()) {
            for (auto i : v_q[u]) {
//                if (i == this_match) continue;
                if (is_show[i]) continue;

                show_match_result.emplace_back(match_result[i], this_match);

                vector<int> dire;
                for (int idx = 0; idx < cp.size() - 1; ++idx)   {
                    int dir = 1;
                    ui nbrs_cnt;
                    int from = abs(cp[idx]);
                    int to = abs(cp[idx + 1]);
                    const VertexID *nbrs1 = data_graph->getVertexDNeighbors(from, nbrs_cnt);

                    auto lb_itr1 = std::lower_bound(nbrs1, nbrs1 + nbrs_cnt, to);
                    if (*lb_itr1 == to && lb_itr1 < nbrs1 + nbrs_cnt && nbrs_cnt) {
                        dir = 1;
                    } else {
                        dir = -1;
                    }
                    if (dir == 1) {
                        const VertexID *nbrs2 = data_graph->getVertexDNeighbors(from, nbrs_cnt);
                        auto lb_itr2 = std::lower_bound(nbrs2, nbrs2 + nbrs_cnt, to);
                        if (*lb_itr2 == to && lb_itr2 < nbrs2 + nbrs_cnt && nbrs_cnt) {
                            dir = 0;
                        }
                    }
                    dire.emplace_back(dir);
                }
                show_path_vec.emplace_back(cp, dire);
                auto cp_bk = cp;
                cp.clear();
                is_show[i] = true;
                ORD.emplace_back(i);
                cal(data_graph, -1, -1, 0, depth + 1, false, i);
                ORD.pop_back();
                show_path_vec.pop_back();
                show_match_result.pop_back();
                cp = cp_bk;
                is_show[i] = false;
            }
        }

        if (d > D) return;

        ui nbrs_cnt;
        const VertexID *nbrs = data_graph->getVertexNeighbors(u, nbrs_cnt);
        for (int i = 0; i < nbrs_cnt; i += SPECIAL) {
            int v = nbrs[i];
            if (!cst[v] && v != fa && d + 1 <= D) {
                cst[v] = true;
                cp.emplace_back(v);
                cal(data_graph, v, u, d + 1, depth, true, this_match);
                cp.pop_back();
                cst[v] = false;
            }
        }
    }
}

unordered_map<int, unordered_map<int, bool>> state;

bool BFS(Graph* data_graph, Graph** query_graph, int cnt)
{
    if (cnt == QUERY_NUMS)
    {
//        for (auto& i : match_result)
//            sort(i.begin(), i.end());

        memset(is_show, false, sizeof (bool) * QUERY_NUMS);
        v_q.clear();
        for (int i = 0; i < QUERY_NUMS; ++i) {
            for (auto j : match_result[i]) {
                v_q[j].emplace_back(i);
            }
        }
        cp.clear();
        memset(cst, false, sizeof (bool) * data_graph->vertices_count_);
        memset(is_show, false, sizeof (bool) * QUERY_NUMS);
        cpath.clear();

        show_path_vec.clear();
        show_match_result.clear();
        show_match_result.emplace_back(match_result[0], 0);

        is_show[0] = true;
        ORD.emplace_back(0);
        cal(data_graph, -1, -1, 0, 1, false, 0);
        ORD.pop_back();
//        for (auto i : match_order)
//            fin << i.first << " ";

        return true;
    }

    bool this_turn = false;

    bool* st;
    st = new bool[data_graph->vertices_count_];
    memset(st, 0, sizeof(bool) * (data_graph->vertices_count_));

//    bool* st1;
//    st1 = new bool[data_graph->vertices_count_];
//    memset(st1, 0, sizeof(bool) * (data_graph->vertices_count_));

    for (const auto& mat : match_result) {
        // 拓展开始
        for (auto mat_vertex: mat) {
            auto vertexs = get_nei_label_vertex[mat_vertex];
            for (const auto &vertex_queryi: vertexs) {
                int vertex = vertex_queryi.first;
                if (state[mat_vertex].find(vertex) != state[mat_vertex].end() || state[vertex].find(mat_vertex) != state[vertex].end()) continue;
                state[mat_vertex][vertex] = true;

                for (auto i: vertex_queryi.second) {
                    if (query_is_matched[i]) continue;

                    ui count = 0;
                    auto itr = query_graph[i]->getVerticesByLabel(data_graph->getVertexLabel(vertex), count);

                    for (int j = 0; j < count; ++j) {
                        try_count++;
                        if (dbg) cout << "(" << cnt << " " << vertex << " " << i << ")" << dl;
                        auto start = std::chrono::high_resolution_clock::now();

                        ui **candidates = nullptr; // candidates[i][j] the i-th node's j-th candidate node
                        ui *candidates_count = nullptr;
                        TreeNode *ceci_tree = nullptr;
                        ui *ceci_order = nullptr;
                        //                        GenerateFilteringPlan::generateCECIFilterPlan(data_graph, query_graph[i], ceci_tree, ceci_order, itr[j]);
                        std::vector<std::unordered_map<VertexID, std::vector<VertexID >>> TE_Candidates;
                        std::vector<std::vector<std::unordered_map<VertexID, std::vector<VertexID>>>> NTE_Candidates;
                        bool filter_res;

                        filter_res = FilterVertices::CECIFilter(data_graph, query_graph[i],
                                                                candidates,
                                                                candidates_count, ceci_order, ceci_tree,
                                                                TE_Candidates,
                                                                NTE_Candidates, itr[j], vertex,
                                                                nullptr);
                        if (!filter_res) {
                            st[vertex] = true;
                            cout << "filter g" << dl;
                            continue;
                        }

                        auto end = std::chrono::high_resolution_clock::now();
                        double filter_vertices_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
                                end - start).count();

                        // Compute the candidates false positive ratio.
#ifdef OPTIMAL_CANDIDATES
                        std::vector<ui> optimal_candidates_count;
    double avg_false_positive_ratio = FilterVertices::computeCandidatesFalsePositiveRatio(data_graph, query_graph, candidates,
                                                                                      candidates_count, optimal_candidates_count);
    FilterVertices::printCandidatesInfo(query_graph, candidates_count, optimal_candidates_count);
#endif
                        //                        std::cout << "-----" << std::endl;
                        //                        std::cout << "Build indices..." << std::endl;

                        start = std::chrono::high_resolution_clock::now();

                        end = std::chrono::high_resolution_clock::now();
                        double build_table_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
                                end - start).count();

                        //                        size_t memory_cost_in_bytes = 0;

                        if (TE_Candidates.empty()) {
                            //                            cout << "no result" << endl;
                            st[vertex] = true;
                            cout << "candidates g" << dl;
                            continue;
                        }
                        //                        memory_cost_in_bytes = BuildTable::computeMemoryCostInBytes(query_graph[i], candidates_count,ceci_order,ceci_tree,TE_Candidates, NTE_Candidates);
                        //        BuildTable::printTableCardinality(query_graph[current], ceci_tree, ceci_order, TE_Candidates, NTE_Candidates);

                        //                        std::cout << "-----" << std::endl;
                        //                        std::cout << "Generate a matching order..." << std::endl;

                        start = std::chrono::high_resolution_clock::now();

                        ui *matching_order = NULL;
                        ui *pivots = NULL;
                        ui **weight_array = NULL;

                        size_t order_num = 0;

                        sscanf(input_order_num.c_str(), "%zu", &order_num);

                        std::vector<std::vector<ui>> spectrum;

                        GenerateQueryPlan::generateCECIQueryPlan(query_graph[i], ceci_tree,
                                                                 ceci_order,
                                                                 matching_order,
                                                                 pivots);


                        end = std::chrono::high_resolution_clock::now();
                        double generate_query_plan_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
                                end - start).count();

                        if (input_order_type != "Spectrum") {
                            GenerateQueryPlan::checkQueryPlanCorrectness(query_graph[i],
                                                                         matching_order,
                                                                         pivots);
                            //                            GenerateQueryPlan::printSimplifiedQueryPlan(query_graph[0], matching_order);
                        } else {
                            std::cout << "Generate " << spectrum.size() << " matching orders."
                                      << std::endl;
                        }

                        //                        std::cout << "-----" << std::endl;
                        //                        std::cout << "Enumerate..." << std::endl;
                        size_t output_limit = 0;
                        size_t embedding_count = 0;
                        if (input_max_embedding_num == "MAX") {
                            output_limit = std::numeric_limits<size_t>::max();
                        } else {
                            sscanf(input_max_embedding_num.c_str(), "%zu", &output_limit);
                        }

#if ENABLE_QFLITER == 1
                        EvaluateQuery::qfliter_bsr_graph_ = BuildTable::qfliter_bsr_graph_;
#endif

                        size_t call_count = 0;
                        size_t time_limit = 0;
                        sscanf(input_time_limit.c_str(), "%zu", &time_limit);

                        start = std::chrono::high_resolution_clock::now();
                        vector<vector<int>> cur_match_res;
                        cur_match_res.reserve(100);

                        embedding_count = EvaluateQuery::exploreCECIStyle(data_graph,
                                                                          query_graph[i],
                                                                          ceci_tree,
                                                                          candidates,
                                                                          candidates_count,
                                                                          TE_Candidates,
                                                                          NTE_Candidates, ceci_order,
                                                                          output_limit,
                                                                          call_count, cur_match_res);
                        //                        memory_cost_in_bytes += sizeof(int) * cur_match_res.size();

                        end = std::chrono::high_resolution_clock::now();
                        double enumeration_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
                                end - start).count();

#ifdef DISTRIBUTION
                        std::ofstream outfile (input_distribution_file_path , std::ofstream::binary);
    outfile.write((char*)EvaluateQuery::distribution_count_, sizeof(size_t) * data_graph->getVerticesCount());
    delete[] EvaluateQuery::distribution_count_;
#endif

                        //                        std::cout << "--------------------------------------------------------------------" << std::endl;
                        //                        std::cout << "Release memories..." << std::endl;
                        /**
                         * Release the allocated memories.
                         */
                        delete[] candidates_count;

                        delete[] ceci_order;
                        delete[] ceci_tree;
                        delete[] matching_order;
                        delete[] pivots;
                        for (ui iii = 0; iii < query_graph[i]->getVerticesCount(); ++iii) {
                            delete[] candidates[iii];
                        }
                        delete[] candidates;

                        /**
                         * End.
                         */

                        //                        queue_size[cnt] = q.size();
                        //                        if (!cur_match_res.empty())
                        //                            res_size[cnt] = cur_match_res.size() * cur_match_res[0].size();
                        //                        if (cnt == QUERY_NUMS - 1) {
                        //                            for (int ij = 1; ij <= QUERY_NUMS; ++ij) {
                        //                                avg_res += queue_size[ij];
                        //                                avg_res2 += res_size[ij];
                        //                            }
                        //                            calculate_count++;
                        //                        }

                        for (const auto &cur_match: cur_match_res) {
                            bool pass = false;
                            auto ordered_ = cur_match;
                            int s = 0;
                            int match_st_idx = -1;
                            bool check1 = true;
                            for (auto k: ordered_) s += k;

                            if (match_st[i].find(ordered_[0]) != match_st[i].end()) {
                                auto it = match_st[i][ordered_[0]];
                                bool pa = true;
                                int pa_cnt = 0;
                                for (int k = 0; k < it.size(); ++k) {
                                    pa_cnt = 0;
                                    if (s == it[k].sum) {
                                        if (it[k].match.size() != ordered_.size())
                                            continue;
                                        for (int l = 0; l < it[k].match.size(); ++l) {
                                            if (it[k].match[l] == ordered_[l]) {
                                                pa_cnt++;
                                            }
                                        }
                                    }
                                    if (pa_cnt == it[k].match.size()) {
                                        //                                        for (auto pa_i : it[k].path) {
                                        //                                            if (tmp_path.size() == pa_i.size()) {
                                        //                                                bool path_is_same = true;
                                        //                                                for (int pa_ = 0; pa_ < pa_i.size(); ++pa_) {
                                        //                                                    if (tmp_path[pa_] != pa_i[pa_]) {
                                        //                                                        path_is_same = false;
                                        //                                                        break;
                                        //                                                    }
                                        //                                                }
                                        //                                                if (path_is_same) {
                                        pa = false;
                                        break;
                                        //                                                }
                                        //                                            }
                                        //                                        }
                                        //                                        if (!pa)
                                        //                                            break;
                                    }
                                }
                                if (!pa) {
                                    continue;
                                }
                            }
                            match_st[i][ordered_[0]].emplace_back(ordered_, s);

                            match_result.emplace_back(cur_match);
                            match_order.emplace_back(i, 0);
                            query_is_matched[i] = true;

                            auto match_st_bk = match_st;
                            bool ok = false;
                            dfs_all_count++;

                            if (BFS(data_graph, query_graph, cnt + 1)) {
                                this_turn = true;
                                ok = true;
                            }

                            match_st = match_st_bk;
                            match_st[i][ordered_[0]].pop_back();
                            if (ok) {
                                match_st[i][ordered_[0]].emplace_back(ordered_, s);
                            }

                            match_result.pop_back();
                            match_order.pop_back();
                            query_is_matched[i] = false;
                        }
                    }
                }
            }
        }
    }

    return this_turn;
}

bool* gst;
int* gdist;

double ttt;

void init(Graph* data_graph , Graph** query_graph, int u) {
    queue<int> q;
    q.push(u);
    while (!q.empty()) {
        auto vertex = q.front();
        int d = gdist[vertex];
        q.pop();

        if (gst[vertex])
            continue;
        gst[vertex] = true;
        if (d > D) continue;

        for (int i = 1; i < QUERY_NUMS; ++i) {
            ui count = 0;
            auto lab = data_graph->getVertexLabel(vertex);
            auto itr = query_graph[i]->getVerticesByLabel(lab, count);
            if (count > 0) {
                for (int j = 0; j < count; ++j) {
                    if (data_graph->getVertexDegree(vertex) < query_graph[i]->getVertexDegree(itr[j])) continue;
                    const std::unordered_map<LabelID, ui> *u_nlf = query_graph[i]->getVertexNLF(itr[j]);
                    const std::unordered_map<LabelID, ui> *v_nlf = data_graph->getVertexNLF(vertex);

                    if (v_nlf->size() >= u_nlf->size()) {
                        bool is_valid = true;
                        for (auto element: *u_nlf) {
                            auto iter = v_nlf->find(element.first);
                            if (iter == v_nlf->end() || iter->second < element.second) {
                                is_valid = false;
                                break;
                            }
                        }
                        if (!is_valid) continue;
                    } else {
                        continue;
                    }
                    get_nei_label_vertex[u][vertex].emplace_back(i);
                }
            }
        }

        // 邻居加入队列
        ui nbrs_cnt;
        const VertexID *nbrs = data_graph->getVertexNeighbors(vertex, nbrs_cnt);
        for (int ii = 0; ii < nbrs_cnt; ii += SPECIAL) {
            VertexID v = nbrs[ii];
            if (!gst[v] && d + 1 <= D) // csr寸的是点值
            {
                q.emplace(v);
                gdist[v] = d + 1;
            }
        }
    }
}

void solve1(double load_graphs_time_in_ns, vector<vector<int>>& all_match_res, Graph** query_graph, Graph* data_graph){
    RE = false;
    auto sstart = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < all_match_res.size(); ++i) {
        sort(all_match_res[i].begin(), all_match_res[i].end());
    }

    sort(all_match_res.begin(), all_match_res.end(), [](vector<int>& a, vector<int>& b) {
        for (int i = 0; i < a.size(); ++i) {
            if (a[i] != b[i])
                return a[i] < b[i];
        }
        return true;
    });

    match_st.reserve(QUERY_NUMS);
    std::cout << "Begin SP Match!" << std::endl;
    cout << "PATH: " << PATH << " Query_Num: " << QUERY_NUMS << " D: " << D << dl;
    for (int i = 0; i < QUERY_NUMS; ++i) {
        match_st[i].reserve(data_graph->vertices_count_);
    }

    size_t store_res=0;
    size_t sz_int = sizeof (int);
    int store_res_count=0;
    int reuse_count = 0;

    for (int i = 0; i < all_match_res.size(); ++i) {
        match_result.clear();
        match_st.clear();
        query_is_matched[0] = true;
        match_result.emplace_back(all_match_res[i]);
        match_order.emplace_back(0, i);
        state.clear();
        auto ordered_ = all_match_res[i];
        int s = 0;
        for (auto j : ordered_) s += j;
        match_st[0][ordered_[0]].emplace_back(ordered_, s);

        if (match_result[0][0] == 18454) {
            dbg = true;
        }
        else
            dbg = false;

        BFS(data_graph, query_graph, 1);

        match_order.pop_back();
        if (!match_st.empty()) {
            for (const auto& ii : match_st) {
                for (const auto& j : ii.second) {
                    for (const auto& k : j.second) {
                        store_res += sizeof(int) * (k.match.size() + 1);
                    }
                }
            }
            store_res_count++;
        }
    }

    auto eend = std::chrono::high_resolution_clock::now();
    double ALL_TIME = std::chrono::duration_cast<std::chrono::nanoseconds>(eend - sstart).count();

    sum_memory_cost_in_bytes += store_res / store_res_count;
    sum_memory_cost_in_bytes += sizeof (bool) * data_graph->vertices_count_ * QUERY_NUMS +
                                sizeof (int) * data_graph->vertices_count_ * QUERY_NUMS +
                                sizeof (int) * data_graph->vertices_count_ * QUERY_NUMS +
                                sizeof (bool) * data_graph->vertices_count_ * QUERY_NUMS;
//    sum_memory_cost_in_bytes += sizeof(int) * (avg_res + avg_res2) / calculate_count;
    printf("Load graphs time (seconds): %.4lf\n", NANOSECTOSEC(sum_load_graphs_time_in_ns));
    printf("Filter vertices time (seconds): %.4lf\n", NANOSECTOSEC(sum_filter_vertices_time_in_ns));
    printf("Generate query plan time (seconds): %.4lf\n", NANOSECTOSEC(sum_generate_query_plan_time_in_ns));
    printf("Enumerate time (seconds): %.4lf\n", NANOSECTOSEC(sum_enumeration_time_in_ns));
    printf("Preprocessing time (seconds): %.4lf\n", NANOSECTOSEC(sum_preprocessing_time_in_ns));
    printf("ALL match call Count: %zu\n", sum_call_count);
    printf("Per match Call Count Time (nanoseconds): %.4lf\n", sum_enumeration_time_in_ns / (sum_call_count == 0 ? 1 : sum_call_count));
    printf("Total time (seconds): %.4lf\n", NANOSECTOSEC(sum_total_time_in_ns));
    printf("Memory cost (MB): %.4lf\n", BYTESTOMB(sum_memory_cost_in_bytes));
    printf("#Embeddings: %d\n", sp_match_res);
    printf("DFS call count: %d\n", dfs_all_count);
    printf("try count: %d\n", try_count);
    printf("ALL Time: %.4lf\n", NANOSECTOSEC(ALL_TIME));
//    printf("Avg queue size: %llu\n", sizeof(int) * (avg_res + avg_res2) / calculate_count);
    t1 = NANOSECTOSEC(ALL_TIME);
    fstream fin = fstream("/home/qsl/VMShare/result.csv", ios::app);
    fin << "BFS_base" << "," << PATH << "," << QUERY_NUMS << "," << D << ","
        //        << NANOSECTOSEC(sum_filter_vertices_time_in_ns) << ","
        //        << NANOSECTOSEC(sum_generate_query_plan_time_in_ns) << ","
        //        << NANOSECTOSEC(sum_enumeration_time_in_ns) << ","
        //        << NANOSECTOSEC(sum_preprocessing_time_in_ns) << ","
        //        << sum_call_count << ","
        //        << sum_enumeration_time_in_ns / (sum_call_count == 0 ? 1 : sum_call_count) << ","
        //        << NANOSECTOSEC(sum_total_time_in_ns) << ","
        << BYTESTOMB(sum_memory_cost_in_bytes) << ","
        << sp_match_res << ","
        << dfs_all_count << ","
        << try_count << ","
        << NANOSECTOSEC(ALL_TIME) << endl;
//    << avg_res / calculate_count << endl;
    fin.close();
    std::cout << "End." << std::endl;
}

double timeee;

void solve2(double load_graphs_time_in_ns, vector<vector<int>>& all_match_res, Graph** query_graph, Graph* data_graph){
    RE = true;
    auto sstart = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < all_match_res.size(); ++i) {
        sort(all_match_res[i].begin(), all_match_res[i].end());
    }

    sort(all_match_res.begin(), all_match_res.end(), [](vector<int>& a, vector<int>& b) {
        for (int i = 0; i < a.size(); ++i) {
            if (a[i] != b[i])
                return a[i] < b[i];
        }
        return true;
    });

    match_st.reserve(QUERY_NUMS);
    std::cout << "Begin SP Match!" << std::endl;
    cout << "PATH: " << PATH << " Query_Num: " << QUERY_NUMS << " D: " << D << dl;
    for (int i =0; i < QUERY_NUMS; ++i) {
        match_st[i].reserve(data_graph->vertices_count_);
    }

    size_t store_res=0;
    size_t sz_int = sizeof (int);
    int store_res_count=0;
    int reuse_count = 0;

    for (int i = 0; i < all_match_res.size(); ++i) {
        match_result.clear();
        matched.clear();
        dont_need_match_vertex.clear();
        match_st.clear();
        query_is_matched[0] = true;
        match_result.emplace_back(all_match_res[i]);
        match_order.emplace_back(0, i);
        auto ordered_ = all_match_res[i];
        int s = 0;
        for (auto j : ordered_) s += j;
        match_st[0][ordered_[0]].emplace_back(ordered_, s);

        for (auto j = re_use.begin(); j != re_use.end(); ) {
            if (j->first < match_result[0][0])
                re_use.erase(j++);
            else
                j++;
        }

        for (int j = 0; j < all_match_res[i].size(); ++j) {
            if (re_use.find(all_match_res[i][j]) != re_use.end()) {
                for (auto each : re_use[all_match_res[i][j]]) {
                    bool ok = true;
                    for (auto each_fa : each.fa) {
                        auto id = lower_bound(all_match_res[i].begin() + j, all_match_res[i].end(), each_fa);
                        if (id == all_match_res[i].end() || *id != each_fa) {
                            ok = false;
                            break;
                        }
                    }
                    if (ok) {
                        dont_need_match_vertex[all_match_res[i][j]] = true;
                        for (auto k : each.fa) {
                            dont_need_match_vertex[k] = true;
                        }
//                        cout << "re ues " << sp_match_res << " ";
//                        cout << sp_match_res << endl;
                        fstream fin = fstream("../../result_dfs2.txt", ios::app);

                        for (int cnt = 0; cnt < each.match.size(); ++cnt) {
                            int sum = 0;
                            for (auto jj : match_result[0]) {
                                if (cot) cout << jj << "(" << data_graph->getVertexLabel(jj) << ")" << " ";
                                if (in_file) fin << jj << "(" << data_graph->getVertexLabel(jj) << ")" << " ";
                            }

                            for (int ii = 0; ii < each.match[cnt].size(); ++ii) {
                                if (cot) cout << "[";
                                if (in_file) fin << "[";
                                for (int jj = 0; jj < each.path[cnt][ii].first.size() - 1; ++jj) {
                                    if (each.path[cnt][ii].second[jj] > 0) {
                                        if (cot) cout << each.path[cnt][ii].first[jj] << "->" << each.path[cnt][ii].first[jj + 1] << " ";
                                        if (in_file) fin << each.path[cnt][ii].first[jj] << "->" << each.path[cnt][ii].first[jj + 1] << " ";
                                    } else if (each.path[cnt][ii].second[jj] < 0) {
                                        if (cot) cout << abs(each.path[cnt][ii].first[jj]) << "<-" << each.path[cnt][ii].first[jj + 1] << " ";
                                        if (in_file) fin << abs(each.path[cnt][ii].first[jj]) << "<-" << each.path[cnt][ii].first[jj + 1] << " ";
                                    } else {
                                        if (cot) cout << abs(each.path[cnt][ii].first[jj]) << "<->" << each.path[cnt][ii].first[jj + 1] << " ";
                                        if (in_file) fin << abs(each.path[cnt][ii].first[jj]) << "<->" << each.path[cnt][ii].first[jj + 1] << " ";
                                    }
//                                    if (jj < each.path[cnt][ii].first.size()) {
//                                        if (cot) cout << ' ';
//                                        if (in_file) fin << ' ';
//                                    }
                                }
                                if (each.path[cnt][ii].first.size() == 1) {
                                    if (cot) cout << each.path[cnt][ii].first[0] << " ";
                                    if (in_file) fin << each.path[cnt][ii].first[0] << " ";
                                }
                                if (cot) cout << "] ";
                                if (in_file) fin << "] ";

                                for (auto jj: each.match[cnt][ii]) {
                                    sum += jj;
                                    if (cot) cout << jj << "(" << data_graph->getVertexLabel(jj) << ")" << " ";
                                    if (in_file) fin << jj << "(" << data_graph->getVertexLabel(jj) << ")" << " ";
                                }
                            }
                            sp_match_res++;
                            reuse_count++;
                            fin << "re use";
                            if (cot) cout << dl;
                            if (in_file) fin << dl;

//                            matched[sum].emplace_back(each.match[cnt]);
                        }
                    }
                }
            }
        }
        BFS(data_graph, query_graph, 1);
        match_order.pop_back();
        if (!match_st.empty()) {
            for (const auto& ii : match_st) {
                for (const auto& j : ii.second) {
                    for (const auto& k : j.second) {
                        store_res += sizeof(int) * (k.match.size() + 1);
                    }
                }
            }
            store_res_count++;
        }
    }

    auto eend = std::chrono::high_resolution_clock::now();
    double ALL_TIME = std::chrono::duration_cast<std::chrono::nanoseconds>(eend - sstart).count();

    size_t re_use_size = 0;

    for (const auto& j : re_use) {
        for (const auto& j1 : j.second) {
            re_use_size += sz_int * j1.fa.size();
            for (const auto& j2 : j1.match) {
                for (const auto& j3 : j2) {
                    re_use_size += sz_int * j3.size();
                }
            }
            for (const auto& j2 : j1.path) {
                for (const auto& j3 : j2) {
                    re_use_size += sz_int * (j3.first.size() + j3.first.size() - 1);
                }
            }
        }
    }

    size_t matched_size = 0;
    for (const auto& j : matched) {
        for (const auto& j1 : j.second) {
            for (const auto& j2 : j1) {
                sum_memory_cost_in_bytes += sz_int * j2.size();
                matched_size += sz_int * j2.size();
            }
        }
    }

    sum_memory_cost_in_bytes += re_use_size;
    sum_memory_cost_in_bytes += store_res / store_res_count;
    sum_memory_cost_in_bytes += sizeof (bool) * data_graph->vertices_count_ * QUERY_NUMS +
                                sizeof (int) * data_graph->vertices_count_ * QUERY_NUMS +
                                sizeof(int) * data_graph->vertices_count_ * QUERY_NUMS +
                                sizeof(bool) * data_graph->vertices_count_ * QUERY_NUMS;
//    sum_memory_cost_in_bytes += sizeof(int) * (avg_res + avg_res2) / calculate_count;
    printf("Load graphs time (seconds): %.4lf\n", NANOSECTOSEC(sum_load_graphs_time_in_ns));
    printf("Filter vertices time (seconds): %.4lf\n", NANOSECTOSEC(sum_filter_vertices_time_in_ns));
    printf("Generate query plan time (seconds): %.4lf\n", NANOSECTOSEC(sum_generate_query_plan_time_in_ns));
    printf("Enumerate time (seconds): %.4lf\n", NANOSECTOSEC(sum_enumeration_time_in_ns));
    printf("Preprocessing time (seconds): %.4lf\n", NANOSECTOSEC(sum_preprocessing_time_in_ns));
    printf("ALL match call Count: %zu\n", sum_call_count);
    printf("Per match Call Count Time (nanoseconds): %.4lf\n", sum_enumeration_time_in_ns / (sum_call_count == 0 ? 1 : sum_call_count));
    printf("Total time (seconds): %.4lf\n", NANOSECTOSEC(sum_total_time_in_ns));
    printf("Memory cost (MB): %.4lf\n", BYTESTOMB(sum_memory_cost_in_bytes));
    cout << "!!!!reuse: " << reuse_count * 1.0 / (sp_match_res) << " " << reuse_count << " " << sp_match_res << endl;
    cout << "re use size : " << BYTESTOMB(re_use_size) << dl;
    cout << "store match size : " << BYTESTOMB(store_res / store_res_count) << dl;
    cout << "use sum to prun size : " << BYTESTOMB(matched_size) << dl;
    printf("#Embeddings: %d\n", sp_match_res);
    printf("DFS call count: %d\n", dfs_all_count);
    printf("try count: %d\n", try_count);
    printf("ALL Time: %.4lf\n", NANOSECTOSEC(ALL_TIME));
    printf("timeeee Time: %.4lf\n", NANOSECTOSEC(timeee));
    cout << timeee / ALL_TIME << dl;
    t2 = NANOSECTOSEC(ALL_TIME);
//    printf("Avg queue size: %llu\n", sizeof(int) * (avg_res + avg_res2) / calculate_count);
    fstream fin = fstream("/home/qsl/VMShare/result.csv", ios::app);
    fin << "BFS_reuse" << "," << PATH << "," << QUERY_NUMS << "," << D << ","
        //        << NANOSECTOSEC(sum_filter_vertices_time_in_ns) << ","
        //        << NANOSECTOSEC(sum_generate_query_plan_time_in_ns) << ","
        //        << NANOSECTOSEC(sum_enumeration_time_in_ns) << ","
        //        << NANOSECTOSEC(sum_preprocessing_time_in_ns) << ","
        //        << sum_call_count << ","
        //        << sum_enumeration_time_in_ns / (sum_call_count == 0 ? 1 : sum_call_count) << ","
        //        << NANOSECTOSEC(sum_total_time_in_ns) << ","
        << BYTESTOMB(sum_memory_cost_in_bytes) << ","
        << sp_match_res << ","
        << dfs_all_count << ","
        << try_count << ","
        << NANOSECTOSEC(ALL_TIME) << "," << (t1-t2)/t1 * 100 << endl;
//        << avg_res / calculate_count << endl;
    fin.close();
    std::cout << "End." << std::endl;
}

int mx = -1;

int main(int argc, char** argv) {
//    MatchingCommand command(argc, argv);
    /*std::string input_query_graph_file = command.getQueryGraphFilePath();
    std::string input_data_graph_file = command.getDataGraphFilePath();
    std::string input_filter_type = command.getFilterType();
    std::string input_order_type = command.getOrderType();
    std::string input_engine_type = command.getEngineType();
    std::string input_max_embedding_num = command.getMaximumEmbeddingNum();
    std::string input_time_limit = command.getTimeLimit();
    std::string input_order_num = command.getOrderNum();
    std::string input_distribution_file_path = command.getDistributionFilePath();
    std::string input_csr_file_path = command.getCSRFilePath();*/
    /**
     * Output the command line information.
     */
    std::cout << "Command Line:" << std::endl;
    std::cout << "\tData Graph CSR: " << input_csr_file_path << std::endl;
    std::cout << "\tData Graph: " << input_data_graph_file << std::endl;
    std::cout << "\tQuery Graph: " << input_query_graph_file << std::endl;
    std::cout << "\tFilter Type: " << input_filter_type << std::endl;
    std::cout << "\tOrder Type: " << input_order_type << std::endl;
    std::cout << "\tEngine Type: " << input_engine_type << std::endl;
    std::cout << "\tOutput Limit: " << input_max_embedding_num << std::endl;
    std::cout << "\tTime Limit (seconds): " << input_time_limit << std::endl;
    std::cout << "\tOrder Num: " << input_order_num << std::endl;
    std::cout << "\tDistribution File Path: " << input_distribution_file_path << std::endl;
    std::cout << "--------------------------------------------------------------------" << std::endl;

    /**
     * Load input graphs.
     */

    std::cout << "Load graphs..." << std::endl;

    auto start = std::chrono::high_resolution_clock::now();

//    Graph* query_graph = new Graph(true);
//    query_graph->loadGraphFromFile(input_query_graph_file);
//    query_graph->buildCoreTable();

    Graph** query_graph = new Graph*[QUERY_NUMS];
    for (int i = 0; i < QUERY_NUMS; ++i) {
        query_graph[i] = new Graph(true);
        query_graph[i]->loadGraphFromFile(input_query_graph_file + "/q" + to_string(i) + ".txt");
//        query_graph[i]->loadGraphFromFile("../../test/querys/4/q0.txt");
        query_graph[i]->buildCoreTable();
    }

    Graph* data_graph = new Graph(true);

    if (input_csr_file_path.empty()) {
        cout << "Load csr file" << endl;
        data_graph->loadGraphFromFile(input_data_graph_file);
    }
    else {
        cout << "NOT Load csr file" << endl;
        std::string degree_file_path = input_csr_file_path + "_deg.bin";
        std::string edge_file_path = input_csr_file_path + "_adj.bin";
        std::string label_file_path = input_csr_file_path + "_label.bin";
        data_graph->loadGraphFromFileCompressed(degree_file_path, edge_file_path, label_file_path);
    }

    auto end = std::chrono::high_resolution_clock::now();

    double load_graphs_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();

    std::cout << "-----" << std::endl;
    std::cout << "Query Graph Meta Information" << std::endl;
    for (int i = 0; i < QUERY_NUMS; ++i)
        query_graph[i]->printGraphMetaData();
//    query_graph->printGraphMetaData();
    std::cout << "-----" << std::endl;
    data_graph->printGraphMetaData();

    std::cout << "--------------------------------------------------------------------" << std::endl;
    match_result.reserve(QUERY_NUMS);
    match_path.reserve(QUERY_NUMS - 1);

    /**
     * Start queries.
     */

    std::cout << "Start queries..." << std::endl;
    std::cout << "-----" << std::endl;
    std::cout << "Filter candidates..." << std::endl;
    ui max_vetex_nums = 0;
    for (int i = 0; i < QUERY_NUMS; ++i) {if (query_graph[i]->vertices_count_ > max_vetex_nums) {max_vetex_nums = query_graph[i]->vertices_count_;}}

    vector<vector<int>> all_match_res;
    all_match_res.reserve(10000);

    start = std::chrono::high_resolution_clock::now();

    ui **candidates = NULL; // candidates[i][j] the i-th node's j-th candidate node
    ui *candidates_count = NULL;

    TreeNode *ceci_tree = NULL;
    ui *ceci_order = NULL;

    GenerateFilteringPlan::generateCECIFilterPlan(data_graph, query_graph[0], ceci_tree, ceci_order, -1);

    std::vector<std::unordered_map<VertexID, std::vector<VertexID >>> TE_Candidates;
    std::vector<std::vector<std::unordered_map<VertexID, std::vector<VertexID>>>> NTE_Candidates;
    bool filter_res;

    filter_res = FilterVertices::CECIFilter(data_graph, query_graph[0], candidates, candidates_count, ceci_order,
                                            ceci_tree, TE_Candidates, NTE_Candidates, -1, -1, nullptr);

    if (!filter_res) {
        cout << "filter not match" << endl;
        return 0;
    }

    end = std::chrono::high_resolution_clock::now();
    double filter_vertices_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();

    // Compute the candidates false positive ratio.
#ifdef OPTIMAL_CANDIDATES
    std::vector<ui> optimal_candidates_count;
        double avg_false_positive_ratio = FilterVertices::computeCandidatesFalsePositiveRatio(data_graph, query_graph, candidates,
                                                                                              candidates_count, optimal_candidates_count);
        FilterVertices::printCandidatesInfo(query_graph, candidates_count, optimal_candidates_count);
#endif
    std::cout << "-----" << std::endl;
    std::cout << "Build indices..." << std::endl;

    start = std::chrono::high_resolution_clock::now();

    Edges ***edge_matrix = NULL;


    end = std::chrono::high_resolution_clock::now();
    double build_table_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();

    size_t memory_cost_in_bytes = 0;

    if (TE_Candidates.empty()) {
        cout << "no result" << endl;
        return 0;
    }
    memory_cost_in_bytes = BuildTable::computeMemoryCostInBytes(query_graph[0], candidates_count, ceci_order,
                                                                ceci_tree,
                                                                TE_Candidates, NTE_Candidates);
//        BuildTable::printTableCardinality(query_graph[current], ceci_tree, ceci_order, TE_Candidates, NTE_Candidates);

    std::cout << "-----" << std::endl;
    std::cout << "Generate a matching order..." << std::endl;

    start = std::chrono::high_resolution_clock::now();

    ui *matching_order = NULL;
    ui *pivots = NULL;
    ui **weight_array = NULL;

    size_t order_num = 0;

    sscanf(input_order_num.c_str(), "%zu", &order_num);

    std::vector<std::vector<ui>> spectrum;

    GenerateQueryPlan::generateCECIQueryPlan(query_graph[0], ceci_tree, ceci_order, matching_order, pivots);


    end = std::chrono::high_resolution_clock::now();
    double generate_query_plan_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
            end - start).count();

    if (input_order_type != "Spectrum") {
        GenerateQueryPlan::checkQueryPlanCorrectness(query_graph[0], matching_order, pivots);
        GenerateQueryPlan::printSimplifiedQueryPlan(query_graph[0], matching_order);
    } else {
        std::cout << "Generate " << spectrum.size() << " matching orders." << std::endl;
    }

    std::cout << "-----" << std::endl;
    std::cout << "Enumerate..." << std::endl;
    size_t output_limit = 0;
    size_t embedding_count = 0;
    if (input_max_embedding_num == "MAX") {
        output_limit = std::numeric_limits<size_t>::max();
    } else {
        sscanf(input_max_embedding_num.c_str(), "%zu", &output_limit);
    }


#if ENABLE_QFLITER == 1
    EvaluateQuery::qfliter_bsr_graph_ = BuildTable::qfliter_bsr_graph_;
#endif

    size_t call_count = 0;
    size_t time_limit = 0;
    sscanf(input_time_limit.c_str(), "%zu", &time_limit);

    start = std::chrono::high_resolution_clock::now();

    embedding_count = EvaluateQuery::exploreCECIStyle(data_graph, query_graph[0], ceci_tree, candidates,
                                                      candidates_count, TE_Candidates,
                                                      NTE_Candidates, ceci_order, output_limit, call_count, all_match_res);
    memory_cost_in_bytes += sizeof(int) * all_match_res.size() * all_match_res[0].size();

    end = std::chrono::high_resolution_clock::now();
    double enumeration_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();

#ifdef DISTRIBUTION
    std::ofstream outfile (input_distribution_file_path , std::ofstream::binary);
        outfile.write((char*)EvaluateQuery::distribution_count_, sizeof(size_t) * data_graph->getVerticesCount());
        delete[] EvaluateQuery::distribution_count_;
#endif

    std::cout << "--------------------------------------------------------------------" << std::endl;
    std::cout << "Release memories..." << std::endl;
    /**
     * Release the allocated memories.
     */
    delete[] candidates_count;

    delete[] ceci_order;
    delete[] ceci_tree;
    delete[] matching_order;
    delete[] pivots;
    for (ui i = 0; i < query_graph[0]->getVerticesCount(); ++i) {
        delete[] candidates[i];
    }
    delete[] candidates;

    /**
     * End.
     */
    std::cout << "--------------------------------------------------------------------" << std::endl;
    double preprocessing_time_in_ns =
            filter_vertices_time_in_ns + build_table_time_in_ns + generate_query_plan_time_in_ns;
    double total_time_in_ns = preprocessing_time_in_ns + enumeration_time_in_ns;

    sum_load_graphs_time_in_ns += load_graphs_time_in_ns;
    sum_filter_vertices_time_in_ns += filter_vertices_time_in_ns;
    sum_build_table_time_in_ns += build_table_time_in_ns;
    sum_generate_query_plan_time_in_ns += generate_query_plan_time_in_ns;
    sum_enumeration_time_in_ns += enumeration_time_in_ns;
    sum_preprocessing_time_in_ns += preprocessing_time_in_ns;
    sum_total_time_in_ns += total_time_in_ns;
    sum_memory_cost_in_bytes += memory_cost_in_bytes;
    printf("First match Memory cost (MB): %.4lf\n", BYTESTOMB(sum_memory_cost_in_bytes));
    sum_embedding_count += embedding_count;
    sum_call_count += call_count;
    printf("#Embeddings: %zu\n", embedding_count);

    std::cout << "query_graph match result:" << std::endl;
    cout << all_match_res.size() << endl;
    std::cout << "--------------------------------------------------------------------" << std::endl;

    cst = new bool[data_graph->vertices_count_];

    auto tt1 = ti;
    bool* has_init;
    has_init = new bool[data_graph->vertices_count_];
    gst = new bool[data_graph->vertices_count_];
    gdist = new int[data_graph->vertices_count_];
    memset(has_init, 0, sizeof(bool) * (data_graph->vertices_count_));

    for (int j = 0; j < data_graph->vertices_count_; ++j) {
        if (!has_init[j]) {
            has_init[j] = true;
            memset(gst, 0, sizeof(bool) * (data_graph->vertices_count_));
            memset(gdist, 0, sizeof(int) * (data_graph->vertices_count_));
            init(data_graph, query_graph, j);
        }
    }
    delete[] has_init;
    delete[] gst;
    delete[] gdist;
    auto tt2 = ti;
    ttt = gti(tt1, tt2);
    cout << cti(ttt) << endl;

    solve1(load_graphs_time_in_ns, all_match_res, query_graph, data_graph);
    match_result.clear();
    match_path.clear();
    match_order.clear();
    matched.clear();
    memset(query_is_matched, 0, sizeof query_is_matched);
    sp_match_res = 0;
    match_st.clear();
    re_use.clear();
    dont_need_match_vertex.clear();
    memset(queue_size, 0, sizeof queue_size);
    avg_res=0;
    calculate_count = 0;
    memset(res_size, 0, sizeof res_size);
    avg_res2=0;
    sum_load_graphs_time_in_ns = 0;
    sum_filter_vertices_time_in_ns = 0;
    sum_build_table_time_in_ns = 0;
    sum_generate_query_plan_time_in_ns = 0;
    sum_enumeration_time_in_ns = 0;
    sum_preprocessing_time_in_ns = 0;
    sum_total_time_in_ns = 0;
    sum_memory_cost_in_bytes = 0;
    sum_embedding_count = 0;
    sum_call_count = 0;
//    solve2(load_graphs_time_in_ns, all_match_res, query_graph, data_graph);
    cout << "improve: " << (t1 - t2) / t1 << endl;
    delete[] query_graph;
    delete data_graph;
    return 0;
}
