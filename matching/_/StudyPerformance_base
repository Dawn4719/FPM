#include <chrono>
#include <future>
#include <thread>
#include <fstream>

#include "matching/matchingcommand.h"
#include "graph/graph.h"
#include "matching/GenerateFilteringPlan.h"
#include "matching/FilterVertices.h"
#include "matching/BuildTable.h"
#include "matching/GenerateQueryPlan.h"
#include "matching/EvaluateQuery.h"

#define qw cout<<endl;
#define dl endl
#define NANOSECTOSEC(elapsed_time) ((elapsed_time)/(double)1000000000)
#define BYTESTOMB(memory_cost) ((memory_cost)/(double)(1024 * 1024))

const string PATH = "95";
const int QUERY_NUMS = 3;
const int D = 2;
int SPECIAL = 2;
int debug_cnt = 0;

bool in_file = true;
bool cot = false;

std::string input_query_graph_file = "../../test/querys/" + PATH;
std::string input_data_graph_file = "../../test/graphs/" + PATH + ".txt";
std::string input_filter_type = "CECI";
std::string input_order_type = "CECI";
std::string input_engine_type = "CECI";
std::string input_max_embedding_num = "MAX";
std::string input_time_limit = "60";
std::string input_order_num = "100";
std::string input_distribution_file_path = "temp.distribution";
std::string input_csr_file_path;
std::string method = "2";

bool dbg;
double sum_load_graphs_time_in_ns = 0;
double sum_filter_vertices_time_in_ns = 0;
double sum_build_table_time_in_ns = 0;
double sum_generate_query_plan_time_in_ns = 0;
double sum_enumeration_time_in_ns = 0;
double sum_preprocessing_time_in_ns = 0;
double sum_total_time_in_ns = 0;
size_t sum_memory_cost_in_bytes = 0;
size_t sum_embedding_count = 0;
size_t sum_call_count = 0;

int try_count;
int dfs_all_count;

vector<vector<int>> match_result;
vector<vector<int>> match_path;
vector<pair<int, int>> match_order;
map<int, vector<pair<vector<int>, vector<int>>>> matched;
vector<vector<bool>> stt;
int mx = -1;
bool query_is_matched[QUERY_NUMS];
int sp_match_res;

unordered_map<int, unordered_map<int, vector<pair<vector<int>, int>>>> match_st;
struct ifm {
    vector<int> fa;
    vector<vector<int>> match;
    vector<vector<int>> path;
};
vector<unordered_map<int, ifm>> re_use;

long long queue_size[10];
long long avg_res;
int calculate_count;
long long res_size[10];
long long avg_res2;

bool BFS(Graph* data_graph, Graph** query_graph, int cnt)
{
    if (cnt == QUERY_NUMS)
    {
/*        auto mo = match_order;
        sort(mo.begin(), mo.end());
        bool have_same = true;
        for (int i = 0; i < QUERY_NUMS; ++i) {
            if (!i && mp_res.find(mo[i].second) == mp_res.end()) {
                mp_res[mo[0].second][mo[1].second][mo[2].second] = true;
                have_same = false;
            }
            if (i == 1 && mp_res[mo[0].second].find(mo[i].second) == mp_res[mo[0].second].end()) {
                mp_res[mo[0].second][mo[1].second][mo[2].second] = true;
                have_same = false;
            }
            if (i == 2 && mp_res[mo[0].second][mo[1].second].find(mo[i].second) == mp_res[mo[0].second][mo[1].second].end()) {
                mp_res[mo[0].second][mo[1].second][mo[2].second] = true;
                have_same = false;
            }
        }
        if (have_same)
            return;*/
        sp_match_res++;

        fstream fin = fstream("../../result1.txt", ios::app);

        for (int i = 0; i < match_result.size(); ++i) {
            if (i) {
                if (cot) cout << "[";
                if (in_file) fin << "[";
                if (!match_path[i - 1].empty())
                    for (int j = match_path[i - 1].size() - 1; j; --j) {
                        if (match_path[i - 1][j] >= 0) {
                            if (cot) cout << match_path[i - 1][j] << "->" << match_path[i - 1][j - 1];
                            if (in_file) fin << match_path[i - 1][j] << "->" << match_path[i - 1][j - 1];
                        } else {
                            if (cot) cout << abs(match_path[i - 1][j]) << "<-" << match_path[i - 1][j - 1];
                            if (in_file) fin << abs(match_path[i - 1][j]) << "<-" << match_path[i - 1][j - 1];
                        }
                        if (~j) {
                            if (cot) cout << ' ';
                            if (in_file) fin << ' ';
                        }
                    }
                if (cot) cout << "] ";
                if (in_file) fin << "] ";
            }
            for (auto j: match_result[i]) {
                if (cot) cout << j <<"(" << data_graph->getVertexLabel(j) << ")" << " ";
                if (in_file) fin << j <<"(" << data_graph->getVertexLabel(j) << ")" << " ";
//                fin << j << " ";
            }
        }
        for (auto i : match_order)
            fin << i.first << " ";
        if (cot) cout << dl;
        if (in_file) fin << dl;
        return true;
    }

    bool* st = new bool[data_graph->vertices_count_];
    int* dist = new int[data_graph->vertices_count_];
    bool* in_queue = new bool[data_graph->vertices_count_];
    memset(st, 0, sizeof(bool) * (data_graph->vertices_count_));
    memset(dist, 0, sizeof(int) * (data_graph->vertices_count_));
    memset(in_queue, 0, sizeof(bool) * (data_graph->vertices_count_));

    queue<int> q;
    for (const auto& pp : match_result) { for (int p : pp) {q.emplace(p);in_queue[p] = true;}}

    int* path = new int[data_graph->vertices_count_]; // 记录路径
    memset(path, -1, sizeof(int) * (data_graph->vertices_count_));
    bool this_turn = false;

    while (!q.empty()) {
        int vertex = q.front(); q.pop();
        assert(vertex < data_graph->vertices_count_);

        int d = dist[vertex];

        if (st[vertex])
            continue;

        // 拓展开始
        for (int i = 1; i < QUERY_NUMS; ++i)
        {
            if (!query_is_matched[i]) { // 查询图i未匹配
                assert(vertex < data_graph->vertices_count_);
//                auto itr = query_graph[i]->getLabelVertexList()->find(data_graph->csr_label[vertex]); // 查询图i是否有点vertex的类别
                ui count = 0;
                try_count++;
                auto itr = query_graph[i]->getVerticesByLabel(data_graph->getVertexLabel(vertex), count);

                if (count > 0) {
                    /*if (matched.find(vertex) != matched.end()) {
                        for (auto p : matched[vertex]) {
                            cout<<2<<dl;
                            vector<int> tmp_path;
                            tmp_path.reserve(5);
                            int find_vertex = vertex;
                            cout<<3<<dl;
                            while (find(match_result.back().fi.begin(), match_result.back().fi.end(),find_vertex) == match_result.back().fi.end() && find_vertex != -1) {
                                tmp_path.emplace_back(find_vertex);
                                find_vertex = path[find_vertex];
                            }

                            if (find_vertex != -1) tmp_path.emplace_back(find_vertex);
                            cout<<4<<dl;
                            int la = tmp_path.back();
                            bool shun = true;
                            assert(la + 2 < data_graph->vertices_count_ + 2);
                            int l = data_graph->dbeg_pos[la + 1], r = data_graph->dbeg_pos[la + 2];
                            assert(l <= data_graph->edge_count);
                            assert(r <= data_graph->edge_count);
                            vector<int> direct;
                            auto p_la = lower_bound(data_graph->dcsr + l, data_graph->dcsr + r, tmp_path[tmp_path.size() - 2] + 1);
//                                    cout << *p_la << dl;
                            if (p_la == data_graph->dcsr + r) {
                                shun = false;
                            } else {
                                if (*p_la == tmp_path[tmp_path.size() - 2] + 1) {
                                    direct.emplace_back(la + 1);
                                    direct.emplace_back(*p_la);
                                    shun = true;
                                } else {
                                    shun = false;
                                }
                            }
                            bool la_shun = ~shun;
                            for (int idx = tmp_path.size() - 2; idx > 0; --idx) {
                                if (!shun) {
                                    assert(tmp_path[idx] + 2 < data_graph->vertices_count_ + 2);
                                    l = data_graph->dbeg_pos[tmp_path[idx] + 1], r = data_graph->dbeg_pos[tmp_path[idx] + 2];
                                    assert(l <= data_graph->edge_count);
                                    assert(r <= data_graph->edge_count);
                                    p_la = lower_bound(data_graph->dcsr + l, data_graph->dcsr + r, tmp_path[idx + 1] + 1);
//                                            cout << *p_la << dl;
                                    if (p_la == data_graph->dcsr + r) {
//                                                cout << shun << dl; // not go

                                    } else {
                                        if (*p_la == tmp_path[idx + 1] + 1) {
                                            if (la_shun != shun)
                                                direct.emplace_back(*p_la);
                                            direct.emplace_back(0-tmp_path[idx + 1]);
                                            la_shun = shun;
                                            shun = true;
                                        } else {
                                            shun = false;
                                        }
                                    }
                                }

                                l = data_graph->dbeg_pos[tmp_path[idx] + 1], r = data_graph->dbeg_pos[tmp_path[idx] + 2];
                                assert(l <= data_graph->edge_count);
                                assert(r <= data_graph->edge_count);
                                p_la = lower_bound(data_graph->dcsr + l, data_graph->dcsr + r, tmp_path[idx - 1] + 1);
//                                        cout << *p_la << dl;
                                if (p_la == data_graph->dcsr + r) {
                                    shun = false;
                                } else {
                                    if (*p_la == tmp_path[idx - 1] + 1) {
                                        direct.emplace_back(*p_la);
                                        la_shun = shun;
                                        shun = true;
                                    } else {
                                        shun = false;
                                    }
                                }
                            }
                            cout<<5<<dl;
                            if (!shun) {
                                l = data_graph->dbeg_pos[tmp_path[0] + 1], r = data_graph->dbeg_pos[tmp_path[0] + 2];
                                assert(l <= data_graph->edge_count);
                                assert(r <= data_graph->edge_count);
                                p_la = lower_bound(data_graph->dcsr + l, data_graph->dcsr + r, tmp_path[0 + 1] + 1);
//                                        cout << *p_la << dl;
                                if (p_la == data_graph->dcsr + r) {
//                                            cout << shun << dl;
                                } else {
                                    if (*p_la == tmp_path[0 + 1] + 1) {
                                        if (la_shun != shun)
                                            direct.emplace_back(*p_la);
                                        direct.emplace_back(0-tmp_path[0 + 1]);
                                    }
                                }
                            }
                            cout<<6<<dl;
                            match_result.emplace_back(direct, vector<int>{});
                            match_result.emplace_back(p);
                            query_is_matched[i] = true;

                            BFS(p.fi, cnt + 1);

                            match_result.pop_back();
                            match_result.pop_back();
                            query_is_matched[i] = false;
                        }
                    } */
                    // vertex是否被匹配过

                    // 查询图i中这个点的候选集，可以通过度数排序之类
                    // 在数据图上进行该查询图的匹配

                    for (int j = 0; j < count; ++j) { // 遍历查询图i与vertex同类别的点的下标
                        if (data_graph->getVertexDegree(vertex) < query_graph[i]->getVertexDegree(itr[j])) continue;
                        /*map<int, int> check_two;
                        for (auto TreeItr : qts[i - 1][j]->queryTree[0].direct_child) {
                            int cur_label = query_graph[i]->csr_label[TreeItr.fi];
                            int cur_direct = TreeItr.se;
                            if (cur_direct >= 0)
                                check_two[cur_label] ++;
                        }
                        if (!check_two.empty()) {
                            bool pass_check = false;
                            int check_cnt = 1;
                            for (int ITR = data_graph->dbeg_pos[vertex + 1];
                                 ITR < data_graph->dbeg_pos[vertex + 2]; ++ITR) {
                                int cur_vertex = data_graph->dcsr[ITR];
                                int cur_label = data_graph->csr_label[cur_vertex - 1];
                                if (check_two.find(cur_label) == check_two.end()) continue;
                                check_two[cur_label]--;

                                if (check_cnt % query_graph[i]->vertices_count_ == 0) {
                                    pass_check = true;
                                    for (auto pass_check_itr: check_two) {
                                        if (pass_check_itr.se > 0) {
                                            pass_check = false;
                                            break;
                                        }
                                    }
                                }
                                if (pass_check) {
                                    break;
                                }
                                check_cnt++;
                            }

                            bool pass_ok = pass_check;
                            if (!pass_check) {
                                for (auto pass_check_itr: check_two) {
                                    if (pass_check_itr.se > 0) {
                                        pass_check = true;
                                        break;
                                    }
                                }
                                if (!pass_check) pass_ok = true;
                                else pass_ok = false;
                            }
                            if (!pass_ok) continue;
                        }*/
                        auto start = std::chrono::high_resolution_clock::now();

                        ui **candidates = nullptr; // candidates[i][j] the i-th node's j-th candidate node
                        ui *candidates_count = nullptr;

                        TreeNode *ceci_tree = nullptr;
                        ui *ceci_order = nullptr;
                        std::vector<std::unordered_map<VertexID, std::vector<VertexID >>> TE_Candidates;
                        std::vector<std::vector<std::unordered_map<VertexID, std::vector<VertexID>>>> NTE_Candidates;
                        bool filter_res;

                        filter_res = FilterVertices::CECIFilter(data_graph, query_graph[i], candidates,
                                                                candidates_count, ceci_order,
                                                                ceci_tree, TE_Candidates, NTE_Candidates, itr[j], vertex, st);
                        if (!filter_res) {
                            continue;
                        }

                        auto end = std::chrono::high_resolution_clock::now();
                        double filter_vertices_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();

                        // Compute the candidates false positive ratio.
#ifdef OPTIMAL_CANDIDATES
                        std::vector<ui> optimal_candidates_count;
        double avg_false_positive_ratio = FilterVertices::computeCandidatesFalsePositiveRatio(data_graph, query_graph, candidates,
                                                                                              candidates_count, optimal_candidates_count);
        FilterVertices::printCandidatesInfo(query_graph, candidates_count, optimal_candidates_count);
#endif
//                        std::cout << "-----" << std::endl;
//                        std::cout << "Build indices..." << std::endl;

                        start = std::chrono::high_resolution_clock::now();

                        end = std::chrono::high_resolution_clock::now();
                        double build_table_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
                                end - start).count();

                        size_t memory_cost_in_bytes = 0;

                        if (TE_Candidates.empty()) {
//                            cout << "no result" << endl;
                            continue;
                        }
                        memory_cost_in_bytes = BuildTable::computeMemoryCostInBytes(query_graph[i], candidates_count,
                                                                                    ceci_order,
                                                                                    ceci_tree,
                                                                                    TE_Candidates, NTE_Candidates);
//        BuildTable::printTableCardinality(query_graph[current], ceci_tree, ceci_order, TE_Candidates, NTE_Candidates);

//                        std::cout << "-----" << std::endl;
//                        std::cout << "Generate a matching order..." << std::endl;

                        start = std::chrono::high_resolution_clock::now();

                        ui *matching_order = NULL;
                        ui *pivots = NULL;
                        ui **weight_array = NULL;

                        size_t order_num = 0;

                        sscanf(input_order_num.c_str(), "%zu", &order_num);

                        std::vector<std::vector<ui>> spectrum;

                        GenerateQueryPlan::generateCECIQueryPlan(query_graph[i], ceci_tree, ceci_order, matching_order,
                                                                 pivots);


                        end = std::chrono::high_resolution_clock::now();
                        double generate_query_plan_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
                                end - start).count();

                        if (input_order_type != "Spectrum") {
                            GenerateQueryPlan::checkQueryPlanCorrectness(query_graph[i], matching_order, pivots);
//                            GenerateQueryPlan::printSimplifiedQueryPlan(query_graph[0], matching_order);
                        } else {
                            std::cout << "Generate " << spectrum.size() << " matching orders." << std::endl;
                        }

//                        std::cout << "-----" << std::endl;
//                        std::cout << "Enumerate..." << std::endl;
                        size_t output_limit = 0;
                        size_t embedding_count = 0;
                        if (input_max_embedding_num == "MAX") {
                            output_limit = std::numeric_limits<size_t>::max();
                        } else {
                            sscanf(input_max_embedding_num.c_str(), "%zu", &output_limit);
                        }

#if ENABLE_QFLITER == 1
                        EvaluateQuery::qfliter_bsr_graph_ = BuildTable::qfliter_bsr_graph_;
#endif

                        size_t call_count = 0;
                        size_t time_limit = 0;
                        sscanf(input_time_limit.c_str(), "%zu", &time_limit);

                        start = std::chrono::high_resolution_clock::now();
                        vector<vector<int>> cur_match_res;
                        cur_match_res.reserve(5000);
                        embedding_count = EvaluateQuery::exploreCECIStyle(data_graph, query_graph[i], ceci_tree,
                                                                          candidates,
                                                                          candidates_count, TE_Candidates,
                                                                          NTE_Candidates, ceci_order, output_limit,
                                                                          call_count, cur_match_res);
                        memory_cost_in_bytes += sizeof(int) * cur_match_res.size();

                        end = std::chrono::high_resolution_clock::now();
                        double enumeration_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();

#ifdef DISTRIBUTION
                        std::ofstream outfile (input_distribution_file_path , std::ofstream::binary);
        outfile.write((char*)EvaluateQuery::distribution_count_, sizeof(size_t) * data_graph->getVerticesCount());
        delete[] EvaluateQuery::distribution_count_;
#endif

//                        std::cout << "--------------------------------------------------------------------" << std::endl;
//                        std::cout << "Release memories..." << std::endl;
                        /**
                         * Release the allocated memories.
                         */
                        delete[] candidates_count;

                        delete[] ceci_order;
                        delete[] ceci_tree;
                        delete[] matching_order;
                        delete[] pivots;
                        for (ui iii = 0; iii < query_graph[i]->getVerticesCount(); ++iii) {
                            delete[] candidates[iii];
                        }
                        delete[] candidates;

                        /**
                         * End.
                         */

                        double preprocessing_time_in_ns = filter_vertices_time_in_ns + build_table_time_in_ns + generate_query_plan_time_in_ns;
                        double total_time_in_ns = preprocessing_time_in_ns + enumeration_time_in_ns;

                        sum_filter_vertices_time_in_ns += filter_vertices_time_in_ns;
                        sum_build_table_time_in_ns += build_table_time_in_ns;
                        sum_generate_query_plan_time_in_ns += generate_query_plan_time_in_ns;
                        sum_enumeration_time_in_ns += enumeration_time_in_ns;
                        sum_preprocessing_time_in_ns += preprocessing_time_in_ns;
                        sum_total_time_in_ns += total_time_in_ns;
                        sum_memory_cost_in_bytes += memory_cost_in_bytes;
                        sum_embedding_count += embedding_count;
                        sum_call_count += call_count;

                        queue_size[cnt] = q.size();
                        if (!cur_match_res.empty())
                            res_size[cnt] = cur_match_res.size() * cur_match_res[0].size();
                        if (cnt == QUERY_NUMS - 1) {
                            for (int ij = 1; ij <= QUERY_NUMS; ++ij) {
                                avg_res += queue_size[ij];
                                avg_res2 += res_size[ij];
                            }
                            calculate_count++;
                        }
                        for (const auto& cur_match: cur_match_res) {
                            bool pass = false;
                            auto ordered_ = cur_match;
                            int s = 0;
                            int match_st_idx = -1;
                            bool check1 = true;
                            for (auto k : ordered_) s += k;
                            if (match_st[i].find(ordered_[0]) != match_st[i].end()) {
                                auto it = match_st[i][ordered_[0]];
                                bool pa = true;
                                int pa_cnt = 0;
                                for (int k = 0; k < it.size(); ++k) {
                                    pa_cnt = 0;
                                    if (s == it[k].second) {
                                        if (it[k].first.size() != ordered_.size())
                                            continue;
                                        for (int l = 0; l < it[k].first.size(); ++l) {
                                            if (it[k].first[l] == ordered_[l]) {
                                                pa_cnt ++;
                                            }
                                        }
                                    }
                                    if (pa_cnt == it[k].first.size()) {
                                        pa = false;
                                        break;
                                    }
                                }
                                if (!pa) {
                                    check1 = false;
                                    continue;
                                }
                            }

                            /* if (last_st.find(ordered_[0]) != last_st.end()) {
                                 auto it = last_st[ordered_[0]];
                                 bool pa = true;
                                 int pa_cnt = 0;
                                 for (int k = 0; k < it.size(); ++k) {
                                     pa_cnt = 0;
                                     if (s == it[k].second) {
                                         if (it[k].first.size() != ordered_.size())
                                             continue;
                                         for (int l = 0; l < it[k].first.size(); ++l) {
                                             if (it[k].first[l] == ordered_[l]) {
                                                 pa_cnt ++;
                                             }
                                         }
                                     }
                                     if (pa_cnt == it[k].first.size()) {
                                         pa = false;
                                         break;
                                     }
                                 }
                                 if (!pa && !check1)
                                     continue;
                             }
                             last_st[ordered_[0]].emplace_back(ordered_, s);*/

                            match_st[i][ordered_[0]].emplace_back(ordered_, s);

                            vector<int> tmp_path;
                            int find_vertex = vertex;
                            while (find(match_result.back().begin(), match_result.back().end(),find_vertex) == match_result.back().end() && find_vertex != -1) {
                                tmp_path.emplace_back(find_vertex);
                                find_vertex = path[find_vertex];
                            }
                            if (find_vertex != -1) tmp_path.emplace_back(find_vertex);

                            for (int idx = tmp_path.size() - 1; idx > 0; --idx) {
                                ui nbrs_cnt;
                                int from = abs(tmp_path[idx]);
                                int to = abs(tmp_path[idx - 1]);
                                const VertexID *nbrs = data_graph->getVertexDNeighbors(from, nbrs_cnt);

                                auto lb_itr = std::lower_bound(nbrs, nbrs + nbrs_cnt, to);
                                if (*lb_itr == to && lb_itr < nbrs + nbrs_cnt && nbrs_cnt) {

                                } else {
                                    tmp_path[idx] = -tmp_path[idx]; // -0=0 :::::::::::::::
                                }
                            }
                            match_path.emplace_back(tmp_path);
                            match_result.emplace_back(cur_match);
                            match_order.emplace_back(i, 0);
                            query_is_matched[i] = true;

                            auto match_st_bk = match_st;
                            bool ok = false;
                            dfs_all_count++;
                            if (BFS(data_graph, query_graph, cnt + 1)) {
                                this_turn = true;
                                ok = true;
                            }

                            match_st = match_st_bk;
                            match_st[i][ordered_[0]].pop_back();
                            if (ok) {
                                match_st[i][ordered_[0]].emplace_back(ordered_, s);
                            }
                            match_path.pop_back();
                            match_result.pop_back();
                            match_order.pop_back();
                            query_is_matched[i] = false;
                        }
                    }
                }
            }
        }
        st[vertex] = true;

        if (d + 1 > D) continue;
        // 邻居加入队列
        ui nbrs_cnt;
        const VertexID *nbrs = data_graph->getVertexNeighbors(vertex, nbrs_cnt);
        for (int ii = 0; ii < nbrs_cnt; ++ii) {
//            if (dist[data_graph->csr[ii] - 1] == 100) continue; // 为匹配过的点
            VertexID v = nbrs[ii];
            if (!st[v]) // csr寸的是点值
            {
                if (dist[v] != 0) // 已经在队列中
                {
                    dist[v] = min(dist[v], d + 1);
                }
                else if (!in_queue[v]) // 不在队列中
                {
                    q.emplace(v);
                    path[v] = vertex;
                    dist[v] = d + 1;
                }
            }
        }
    }
    delete []path;
    delete []st;
    delete []dist;
    delete []in_queue;
    return this_turn;
}

void solve1(double load_graphs_time_in_ns, Graph** query_graph, Graph* data_graph){
    /**
     * Start queries.
     */
    auto sstart = std::chrono::high_resolution_clock::now();
    std::cout << "Start queries..." << std::endl;
    std::cout << "-----" << std::endl;
    std::cout << "Filter candidates..." << std::endl;
    ui max_vetex_nums = 0;
    for (int i = 0; i < QUERY_NUMS; ++i) {if (query_graph[i]->vertices_count_ > max_vetex_nums) {max_vetex_nums = query_graph[i]->vertices_count_;}}

    vector<vector<int>> all_match_res;
    all_match_res.reserve(10000);

    auto start = std::chrono::high_resolution_clock::now();

    ui **candidates = NULL; // candidates[i][j] the i-th node's j-th candidate node
    ui *candidates_count = NULL;

    TreeNode *ceci_tree = NULL;
    ui *ceci_order = NULL;
    std::vector<std::unordered_map<VertexID, std::vector<VertexID >>> TE_Candidates;
    std::vector<std::vector<std::unordered_map<VertexID, std::vector<VertexID>>>> NTE_Candidates;
    bool filter_res;

    filter_res = FilterVertices::CECIFilter(data_graph, query_graph[0], candidates, candidates_count, ceci_order,
                                            ceci_tree, TE_Candidates, NTE_Candidates, -1, -1, nullptr);

    if (!filter_res) {
        cout << "filter not match" << endl;
        return;
    }

    auto end = std::chrono::high_resolution_clock::now();
    double filter_vertices_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();

    // Compute the candidates false positive ratio.
#ifdef OPTIMAL_CANDIDATES
    std::vector<ui> optimal_candidates_count;
        double avg_false_positive_ratio = FilterVertices::computeCandidatesFalsePositiveRatio(data_graph, query_graph, candidates,
                                                                                              candidates_count, optimal_candidates_count);
        FilterVertices::printCandidatesInfo(query_graph, candidates_count, optimal_candidates_count);
#endif
    std::cout << "-----" << std::endl;
    std::cout << "Build indices..." << std::endl;

    start = std::chrono::high_resolution_clock::now();

    Edges ***edge_matrix = NULL;


    end = std::chrono::high_resolution_clock::now();
    double build_table_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();

    size_t memory_cost_in_bytes = 0;

    if (TE_Candidates.empty()) {
        cout << "no result" << endl;
        return;
    }
    memory_cost_in_bytes = BuildTable::computeMemoryCostInBytes(query_graph[0], candidates_count, ceci_order,
                                                                ceci_tree,
                                                                TE_Candidates, NTE_Candidates);
//        BuildTable::printTableCardinality(query_graph[current], ceci_tree, ceci_order, TE_Candidates, NTE_Candidates);

    std::cout << "-----" << std::endl;
    std::cout << "Generate a matching order..." << std::endl;

    start = std::chrono::high_resolution_clock::now();

    ui *matching_order = NULL;
    ui *pivots = NULL;
    ui **weight_array = NULL;

    size_t order_num = 0;

    sscanf(input_order_num.c_str(), "%zu", &order_num);

    std::vector<std::vector<ui>> spectrum;

    GenerateQueryPlan::generateCECIQueryPlan(query_graph[0], ceci_tree, ceci_order, matching_order, pivots);


    end = std::chrono::high_resolution_clock::now();
    double generate_query_plan_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
            end - start).count();

    if (input_order_type != "Spectrum") {
        GenerateQueryPlan::checkQueryPlanCorrectness(query_graph[0], matching_order, pivots);
        GenerateQueryPlan::printSimplifiedQueryPlan(query_graph[0], matching_order);
    } else {
        std::cout << "Generate " << spectrum.size() << " matching orders." << std::endl;
    }

    std::cout << "-----" << std::endl;
    std::cout << "Enumerate..." << std::endl;
    size_t output_limit = 0;
    size_t embedding_count = 0;
    if (input_max_embedding_num == "MAX") {
        output_limit = std::numeric_limits<size_t>::max();
    } else {
        sscanf(input_max_embedding_num.c_str(), "%zu", &output_limit);
    }


#if ENABLE_QFLITER == 1
    EvaluateQuery::qfliter_bsr_graph_ = BuildTable::qfliter_bsr_graph_;
#endif

    size_t call_count = 0;
    size_t time_limit = 0;
    sscanf(input_time_limit.c_str(), "%zu", &time_limit);

    start = std::chrono::high_resolution_clock::now();

    embedding_count = EvaluateQuery::exploreCECIStyle(data_graph, query_graph[0], ceci_tree, candidates,
                                                      candidates_count, TE_Candidates,
                                                      NTE_Candidates, ceci_order, output_limit, call_count, all_match_res);
    memory_cost_in_bytes += sizeof(int) * all_match_res.size();

    end = std::chrono::high_resolution_clock::now();
    double enumeration_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();

#ifdef DISTRIBUTION
    std::ofstream outfile (input_distribution_file_path , std::ofstream::binary);
        outfile.write((char*)EvaluateQuery::distribution_count_, sizeof(size_t) * data_graph->getVerticesCount());
        delete[] EvaluateQuery::distribution_count_;
#endif

    std::cout << "--------------------------------------------------------------------" << std::endl;
    std::cout << "Release memories..." << std::endl;
    /**
     * Release the allocated memories.
     */
    delete[] candidates_count;

    delete[] ceci_order;
    delete[] ceci_tree;
    delete[] matching_order;
    delete[] pivots;
    for (ui i = 0; i < query_graph[0]->getVerticesCount(); ++i) {
        delete[] candidates[i];
    }
    delete[] candidates;

    /**
     * End.
     */
    std::cout << "--------------------------------------------------------------------" << std::endl;
    double preprocessing_time_in_ns =
            filter_vertices_time_in_ns + build_table_time_in_ns + generate_query_plan_time_in_ns;
    double total_time_in_ns = preprocessing_time_in_ns + enumeration_time_in_ns;

    sum_load_graphs_time_in_ns += load_graphs_time_in_ns;
    sum_filter_vertices_time_in_ns += filter_vertices_time_in_ns;
    sum_build_table_time_in_ns += build_table_time_in_ns;
    sum_generate_query_plan_time_in_ns += generate_query_plan_time_in_ns;
    sum_enumeration_time_in_ns += enumeration_time_in_ns;
    sum_preprocessing_time_in_ns += preprocessing_time_in_ns;
    sum_total_time_in_ns += total_time_in_ns;
    sum_memory_cost_in_bytes += memory_cost_in_bytes;
    sum_memory_cost_in_bytes += sizeof(int) * all_match_res.size() * all_match_res[0].size();
    sum_embedding_count += embedding_count;
    sum_call_count += call_count;
    printf("#Embeddings: %zu\n", embedding_count);

    std::cout << "query_graph match result:" << std::endl;
    cout << all_match_res.size() << endl;
    std::cout << "--------------------------------------------------------------------" << std::endl;

    for (int i = 0; i < all_match_res.size(); ++i) {
        sort(all_match_res[i].begin(), all_match_res[i].end());
    }

    sort(all_match_res.begin(), all_match_res.end(), [](vector<int>& a, vector<int>& b) {
        for (int i = 0; i < a.size(); ++i) {
            if (a[i] != b[i])
                return a[i] < b[i];
        }
        return true;
    });

    match_st.reserve(QUERY_NUMS);
    std::cout << "Begin SP Match!" << std::endl;
    for (int i =0; i < QUERY_NUMS; ++i) {
        match_st[i].reserve(data_graph->vertices_count_);
    }
    size_t store_res=0;
    int store_res_count=0;
    for (int i = 0; i < all_match_res.size(); ++i) {
        match_result.clear();
        match_st.clear();
        query_is_matched[0] = true;
        match_result.emplace_back(all_match_res[i]);
        match_order.emplace_back(0, i);

        auto ordered_ = all_match_res[i];
        int s = 0;
        for (auto j : ordered_) s += j;
        match_st[0][ordered_[0]].emplace_back(ordered_, s);

        BFS(data_graph, query_graph, 1);
        match_order.pop_back();
        if (!match_st.empty()) {
            for (const auto& ii : match_st) {
                for (const auto& j : ii.second) {
                    for (const auto& k : j.second) {
                        store_res += sizeof(int) * (k.first.size() + 1);
                    }
                }
            }
            store_res_count++;
        }
    }

    auto eend = std::chrono::high_resolution_clock::now();
    double ALL_TIME = std::chrono::duration_cast<std::chrono::nanoseconds>(eend - sstart).count();

    sum_memory_cost_in_bytes += store_res / store_res_count;
    sum_memory_cost_in_bytes += sizeof (bool) * data_graph->vertices_count_ * QUERY_NUMS +
                                sizeof (int) * data_graph->vertices_count_ * QUERY_NUMS +
                                sizeof(int) * data_graph->vertices_count_ * QUERY_NUMS +
                                sizeof(bool) * data_graph->vertices_count_ * QUERY_NUMS;
    sum_memory_cost_in_bytes += sizeof(int) * (avg_res + avg_res2) / calculate_count;
    printf("Load graphs time (seconds): %.4lf\n", NANOSECTOSEC(sum_load_graphs_time_in_ns));
    printf("Filter vertices time (seconds): %.4lf\n", NANOSECTOSEC(sum_filter_vertices_time_in_ns));
    printf("Generate query plan time (seconds): %.4lf\n", NANOSECTOSEC(sum_generate_query_plan_time_in_ns));
    printf("Enumerate time (seconds): %.4lf\n", NANOSECTOSEC(sum_enumeration_time_in_ns));
    printf("Preprocessing time (seconds): %.4lf\n", NANOSECTOSEC(sum_preprocessing_time_in_ns));
    printf("ALL match call Count: %zu\n", sum_call_count);
    printf("Per match Call Count Time (nanoseconds): %.4lf\n", sum_enumeration_time_in_ns / (sum_call_count == 0 ? 1 : sum_call_count));
    printf("Total time (seconds): %.4lf\n", NANOSECTOSEC(sum_total_time_in_ns));
    printf("Memory cost (MB): %.4lf\n", BYTESTOMB(sum_memory_cost_in_bytes));
    printf("#Embeddings: %d\n", sp_match_res);
    printf("DFS call count: %d\n", dfs_all_count);
    printf("try count: %d\n", try_count);
    printf("ALL Time: %.4lf\n", NANOSECTOSEC(ALL_TIME));
    printf("Avg queue size: %llu\n", sizeof(int) * (avg_res + avg_res2) / calculate_count);
    fstream fin = fstream("/home/qsl/VMShare/result.csv", ios::app);
    fin << "BFS" << "," << PATH << "," << QUERY_NUMS << "," << D << ","
        << NANOSECTOSEC(sum_filter_vertices_time_in_ns) << ","
        << NANOSECTOSEC(sum_generate_query_plan_time_in_ns) << ","
        << NANOSECTOSEC(sum_enumeration_time_in_ns) << ","
        << NANOSECTOSEC(sum_preprocessing_time_in_ns) << ","
        << sum_call_count << ","
        << sum_enumeration_time_in_ns / (sum_call_count == 0 ? 1 : sum_call_count) << ","
        << NANOSECTOSEC(sum_total_time_in_ns) << ","
        << BYTESTOMB(sum_memory_cost_in_bytes) << ","
        << sp_match_res << ","
        << dfs_all_count << ","
        << try_count << ","
        << NANOSECTOSEC(ALL_TIME) << ","
        << avg_res / call_count << endl;
    fin.close();
    std::cout << "End." << std::endl;
}

int main(int argc, char** argv) {
//    MatchingCommand command(argc, argv);
    /*std::string input_query_graph_file = command.getQueryGraphFilePath();
    std::string input_data_graph_file = command.getDataGraphFilePath();
    std::string input_filter_type = command.getFilterType();
    std::string input_order_type = command.getOrderType();
    std::string input_engine_type = command.getEngineType();
    std::string input_max_embedding_num = command.getMaximumEmbeddingNum();
    std::string input_time_limit = command.getTimeLimit();
    std::string input_order_num = command.getOrderNum();
    std::string input_distribution_file_path = command.getDistributionFilePath();
    std::string input_csr_file_path = command.getCSRFilePath();*/

    /**
     * Output the command line information.
     */
    std::cout << "Command Line:" << std::endl;
    std::cout << "\tData Graph CSR: " << input_csr_file_path << std::endl;
    std::cout << "\tData Graph: " << input_data_graph_file << std::endl;
    std::cout << "\tQuery Graph: " << input_query_graph_file << std::endl;
    std::cout << "\tFilter Type: " << input_filter_type << std::endl;
    std::cout << "\tOrder Type: " << input_order_type << std::endl;
    std::cout << "\tEngine Type: " << input_engine_type << std::endl;
    std::cout << "\tOutput Limit: " << input_max_embedding_num << std::endl;
    std::cout << "\tTime Limit (seconds): " << input_time_limit << std::endl;
    std::cout << "\tOrder Num: " << input_order_num << std::endl;
    std::cout << "\tDistribution File Path: " << input_distribution_file_path << std::endl;
    std::cout << "--------------------------------------------------------------------" << std::endl;

    /**
     * Load input graphs.
     */
    std::cout << "Load graphs..." << std::endl;

    auto start = std::chrono::high_resolution_clock::now();

//    Graph* query_graph = new Graph(true);
//    query_graph->loadGraphFromFile(input_query_graph_file);
//    query_graph->buildCoreTable();
    Graph** query_graph = new Graph*[QUERY_NUMS];
    for (int i = 0; i < QUERY_NUMS; ++i) {
        query_graph[i] = new Graph(true);
        query_graph[i]->loadGraphFromFile(input_query_graph_file + "/q" + to_string(i) + ".txt");
//        query_graph[i]->loadGraphFromFile("../../test/querys/4/q0.txt");
        query_graph[i]->buildCoreTable();
    }

    Graph* data_graph = new Graph(true);

    if (input_csr_file_path.empty()) {
        cout << "Load csr file" << endl;
        data_graph->loadGraphFromFile(input_data_graph_file);
    }
    else {
        cout << "NOT Load csr file" << endl;
        std::string degree_file_path = input_csr_file_path + "_deg.bin";
        std::string edge_file_path = input_csr_file_path + "_adj.bin";
        std::string label_file_path = input_csr_file_path + "_label.bin";
        data_graph->loadGraphFromFileCompressed(degree_file_path, edge_file_path, label_file_path);
    }

    auto end = std::chrono::high_resolution_clock::now();

    double load_graphs_time_in_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count();

    std::cout << "-----" << std::endl;
    std::cout << "Query Graph Meta Information" << std::endl;
    for (int i = 0; i < QUERY_NUMS; ++i)
        query_graph[i]->printGraphMetaData();
//    query_graph->printGraphMetaData();
    std::cout << "-----" << std::endl;
    data_graph->printGraphMetaData();

    std::cout << "--------------------------------------------------------------------" << std::endl;
    match_result.reserve(QUERY_NUMS);
    match_path.reserve(QUERY_NUMS - 1);

//    if (METHOD == 1)
    solve1(load_graphs_time_in_ns, query_graph, data_graph);
//    else
//    solve2(load_graphs_time_in_ns, query_graph, data_graph);
    return 0;
}
